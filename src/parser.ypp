%{
#define YYDEBUG 1

    #include <string>
    #include <iostream>
    #include <vector>
    #include "ast.hpp"


    int yylex();
    Block* parsedProgram;
    using namespace std;

    void yyerror(char const * msg) {
        cerr << msg << endl;
    }
%}

%union {
    Block* block;
    Statement* statement;
    vector<Statement*>* statements;
    Expression* expression;
    Assignment* assignment;
    vector<Assignment*>* assignments;

    Type* type;
    ReferenceId* referenceId;
    ComplexType* complexType;
    vector<TypedId>* typedIds;
    TypedId* typedId;
    FunctionType* functionType;
    FunctionCall* functionCall;

    string* string;
    int integer;
}

%token LET DEF
%token PLUS MINUS TIMES
%token LPARENT RPARENT EQUALS SEMICOLON COLON ARROW DOT COMMA
%token <integer> INT
%token <string> STRING
%token <string> ID

%type <block> program
%type <statements> chainedStatements
%type <statement> statement
%type <expression> expression term factor minusSomething smallestThing memberChain construct
%type <assignment> letOrDef
%type <assignment> assignment
%type <functionCall> functionCall

%type <type> type typeWithoutFunctionType
%type <complexType> complexType
%type <typedIds> typedIds
%type <typedId> typedId
%type <functionType> functionType
%type <assignments> constructItems

%start program

%%
program:
      chainedStatements                 {   parsedProgram = new Block(*$1); }
    ;
chainedStatements:
      chainedStatements statement       {
                                            $$ = $1;
                                            $$->push_back($2);
                                        }
    | statement                         {
                                            $$ = new vector<Statement*>();
                                            $$->push_back($1);
                                        }
    ;
statement:
      expression SEMICOLON              {   $$ = $1; }
    | letOrDef SEMICOLON                {   $$ = $1; }
    ;
expression:
    term
    ;
term:
      term PLUS factor                  {   $$ = new PlusOp($1, $3); }
    | term MINUS factor                 {   $$ = new MinusOp($1, $3); }
    | factor
    ;
factor:
      factor TIMES minusSomething       {   $$ = new TimesOp($1, $3); }
    | minusSomething
    ;
minusSomething:
      MINUS memberChain                 {   $$ = new Negation($2); }
    | memberChain                       {   $$ = $1; }
    ;
memberChain:
	  memberChain DOT ID                {   $$ = new MemberSelection($1, *$3); }
    //| memberChain DOT INT             {   $$ = new ArraySelection($1, $3); }
    | memberChain DOT functionCall      {   $$ = new InfixFunctionCall($1, $3); }
    | smallestThing                     {   $$ = $1; }
    ;
smallestThing:
      LPARENT expression RPARENT        {   $$ = $2; }
    | INT                               {   $$ = new IntValue($1); }
    | STRING                            {   $$ = new StringValue(*$1); }
    | type                              {   $$ = $1; }
    | functionCall                      {   $$ = $1; }
    | construct                         {   $$ = $1; }
    ;
letOrDef:
      DEF assignment                    {   $$ = $2; }
    | LET assignment                    {   $$ = $2; }
    ;
assignment:
      ID EQUALS expression              {   $$ = new Assignment(*$1, $3); }
    //| ID COLON typeWithoutFunctionType EQUALS expression {    $$ = new FunctionDeclaration(*$1, $3, $5); }
    //| ID COLON functionType EQUALS expression             { $$ = new TypedAssignment(*$1, $3); }
    ;
type:
      typeWithoutFunctionType           {   $$ = $1; }
    | functionType                      {   $$ = $1; }
    ;
typeWithoutFunctionType:
      ID                                {   $$ = new ReferenceId(*$1); }
    | complexType                       {   $$ = $1; }
    //| ID L_SQ_BRACKET type R_SQ_BRACKET {   $$ = new ArrayType(*$1, $3); }
    ;
complexType:
      LPARENT typedIds RPARENT          {   $$ = new ComplexType(*$2); }
    ;
typedIds:
      typedIds COMMA typedId            {
                                            $$ = $1;
                                            $$->push_back(*$3);
                                        }
    | typedId                           {
                                            $$ = new vector<TypedId>();
                                            $$->push_back(*$1);
                                        }
    ;
typedId:
      ID COLON type                     {   $$ = new TypedId(*$1, $3); }
    ;
functionType:
      ID ARROW type                     {   $$ = new IdFunctionType(*$1, $3); }
    | complexType ARROW type            {   $$ = new ParameterFunctionType($1, $3); }
    | LPARENT RPARENT ARROW type        {   $$ = new ParameterLessFunctionType($4); }
    ;
functionCall:
      ID LPARENT RPARENT                {   $$ = new ParameterLessFunctionCall(*$1); }
    | ID smallestThing                  {   $$ = new ParametrisedFunctionCall(*$1, $2); }
    ;
construct:
      LPARENT constructItems RPARENT    {   $$ = new Construct(*$2); }
    ;
constructItems:
      constructItems COMMA assignment   {
                                            $$ = $1;
                                            $$->push_back($3);
                                        }
    | assignment                        {
                                            $$ = new vector<Assignment*>();
                                            $$->push_back($1);
                                        }
    ;
%%
