%{
	#include <string>
	#include <iostream>
	#include <vector>
	#include "ast.hpp"


	int yylex();
	Program* parsedProgram;
	using namespace std;
	
	void yyerror(char const * msg) {
		cerr << msg << endl;	
	}

	void indent(vector<string>* target, vector<string>* lines) {
		for(string line: *lines) {
			target->push_back("    " + line);
		}
	}
%}

%union {
    Program* program;
    Statement* statement;
    Expression* expression;
    Assignment* assignment;
    TypeDeclaration* typeDeclaration;
    string* string;
    int integer;
    int token;    
}

%token <integer> INT
%token PLUS MINUS TIMES
%token LPARENT RPARENT EQUALS SEMICOLON COLON ARROW DOT COMMA
%token <string> STRING
%token <string> ID

%type <program> program
%type <program> chainedStatements
%type <statement> statement
%type <expression> expression term factor minusSomething smallestThing
%type <assignment> assignment
%type <typeDeclaration> typeDeclaration
%type <string> typeItemList typeItem

%start program

%%
program:
	chainedStatements { 
			parsedProgram = $1;
		}
	;
chainedStatements:
    chainedStatements statement {
            $1->addStatement($2);
            $$ = $1;
        }
    | statement {
            auto prog = new Program();
            prog->addStatement($1);
            $$ = prog;        
        }
    ;
statement:
    expression SEMICOLON { $$ = $1; }
    | assignment SEMICOLON { $$ = $1; }
    ;
expression:
	term
	;
term:
	term PLUS factor {
            $$ = new PlusOp($1, $3);
		}
    | term MINUS factor {
			$$ = new MinusOp($1, $3);
		}
	| factor
    ;
factor:
	factor TIMES minusSomething { 
			$$ = new TimesOp($1, $3);
		}
	| minusSomething
	;
minusSomething:
	MINUS smallestThing {
			$$ = new Negation($2);
		}
	| smallestThing
	;
smallestThing:
	LPARENT expression RPARENT { 
			$$ = $2;
		}
	| INT { 
            $$ = new IntValue($1);
		}
    | STRING {
            $$ = new StringValue(*$1);
        }
    | ID {
            $$ = new EvalId(*$1);
        }
	;
assignment:
    ID EQUALS expression { 
            $$ = new ExpressionAssignment(*$1, $3);
        }
    | ID EQUALS typeDeclaration { 
            $$ = new TypeAssignment(*$1, $3);
        }
    ;
typeDeclaration:
    LPARENT typeItemList RPARENT { 
			$$ = new TypeDeclaration(*$2);
		}
    ;
typeItemList:
    typeItemList COMMA typeItem { 
			$$ = new string(*$1 + ", " + *$3);
		}
    | typeItem
    ;
typeItem:
    ID COLON ID { 
			$$ = new string(*$1 + ": type(" + *$3 + ")");
		}
    ;
%%

