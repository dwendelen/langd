%{
	#include <string>
	#include <iostream>
	#include <vector>
	#include "ast.hpp"


	int yylex();
	Program* parsedProgram;
	using namespace std;

	void yyerror(char const * msg) {
		cerr << msg << endl;
	}

	void indent(vector<string>* target, vector<string>* lines) {
		for(string line: *lines) {
			target->push_back("    " + line);
		}
	}
%}

%union {
    Program* program;
    Statement* statement;
    Expression* expression;
    Assignment* assignment;

    Type* type;
    SimpleType* simpleType;
    ComplexType* complexType;
    vector<TypedId*>* typedIdList;
    TypedId* typedId;
    FunctionType* functionType;

    string* string;
    int integer;
}

%token LET DEF
%token PLUS MINUS TIMES
%token LPARENT RPARENT EQUALS SEMICOLON COLON ARROW DOT COMMA
%token <integer> INT
%token <string> STRING
%token <string> ID

%type <program> program
%type <program> chainedStatements
%type <statement> statement
%type <expression> expression term factor minusSomething smallestThing
%type <assignment> assignment
%type <assignment> assignmentWithoutKeyword

%type <type> type
%type <complexType> complexType
%type <typedIdList> typedIdList
%type <typedId> typedId
%type <functionType> functionType

%start program

%%
program:
	chainedStatements                   {   parsedProgram = $1; }
	;
chainedStatements:
      chainedStatements statement       {
                                            $1->addStatement($2);
                                            $$ = $1;
                                        }
    | statement                         {
                                            $$ = new Program();
                                            $$->addStatement($1);
                                        }
    ;
statement:
      expression SEMICOLON              {   $$ = $1; }
    | assignment SEMICOLON              {   $$ = $1; }
    ;
expression:
	term
	;
term:
	  term PLUS factor                  {   $$ = new PlusOp($1, $3); }
    | term MINUS factor                 {   $$ = new MinusOp($1, $3); }
	| factor
    ;
factor:
	  factor TIMES minusSomething       {   $$ = new TimesOp($1, $3); }
	| minusSomething
	;
minusSomething:
	  MINUS smallestThing               {   $$ = new Negation($2); }
	| smallestThing
	;
smallestThing:
	  LPARENT expression RPARENT        {   $$ = $2; }
	| INT                               {   $$ = new IntValue($1); }
    | STRING                            {   $$ = new StringValue(*$1); }
    | ID                                {   $$ = new EvalId(*$1); }
	;
assignment:
      DEF assignmentWithoutKeyword      {   $$ = $2; }
    | LET assignmentWithoutKeyword      {   $$ = $2; }
    ;
assignmentWithoutKeyword:
      ID EQUALS expression              {   $$ = new ExpressionAssignment(*$1, $3); }
    | ID EQUALS functionType            {   $$ = new TypeAssignment(*$1, $3); }
    | ID EQUALS complexType             {   $$ = new TypeAssignment(*$1, $3); }
    ;
type:
      ID                                {   $$ = new SimpleType(*$1); }
    | complexType                       {   $$ = $1; }
    | functionType                      {   $$ = $1; }
    ;
complexType:
      LPARENT typedIdList RPARENT       {
			                                $$ = new ComplexType();
                                            for(TypedId* member: *$2) {
                                                $$->addMember(*member);
                                            }
	                                    }
    ;
typedIdList:
      typedIdList COMMA typedId         {
                                            $$ = $1;
                                            $$->push_back($3);
		                                }
    | typedId                           {
                                            $$ = new vector<TypedId*>();
                                            $$->push_back($1);
                                        }
    ;
typedId:
      ID COLON type                     {   $$ = new TypedId(*$1, $3); }
    ;
functionType:
      ID ARROW type                     {   $$ = new IdFunctionType(*$1, $3); }
    | complexType ARROW type            {   $$ = new ParameterFunctionType($1, $3); }
    | LPARENT RPARENT ARROW type        {   $$ = new ParameterLessFunctionType($4); }
    ;
%%

